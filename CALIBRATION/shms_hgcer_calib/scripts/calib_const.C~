#include "Fit/Fitter.h"
#include "Fit/BinData.h"
#include "Fit/Chi2FCN.h"
#include "TH1.h"
#include "TList.h"
#include "TCanvas.h"
#include "TStyle.h"
#include "TFile.h"

Double_t poisson(Double_t *x, Double_t *par)
{
  Double_t result1 = (par[1]*pow(par[0],x[0])*exp(-par[0]))/(ROOT::Math::tgamma(x[0]+1));
  return result1;
}

Double_t gauss(Double_t *x, Double_t *par)
{
  Double_t result1 = par[0]*exp((-0.5)*(pow((x[0] - par[1]),2)/pow((par[2]),2)));
  Double_t result2 = par[3]*exp((-0.5)*(pow((x[0] - par[4]),2)/pow((par[5]),2)));
  Double_t result3 = par[6]*exp((-0.5)*(pow((x[0] - par[7]),2)/pow((par[8]),2)));
  Double_t result4 = par[9]*exp((-0.5)*(pow((x[0] - par[10]),2)/pow((par[11]),2)));
  Double_t result5 = par[12]*exp((-0.5)*(pow((x[0] - par[13]),2)/pow((par[14]),2)));
  return result1 + result2 + result3 + result4 + result5;
}

Double_t linear(Double_t *x, Double_t *par)
{
  Double_t result1 = par[0]*x[0] + par[1];
  return result1;
}

void calib_const(Int_t RunNumber=0)
{
  if (RunNumber == 0)
    {
      cout << "Enter a Run Number (-1 to exit): ";
      cin >> RunNumber;
      if (RunNumber <= 0) return;
      else TFile *F = new TFile(Form("../root_files/shms_calibration_%d.root", RunNumber));
    }
  else TFile *F = new TFile(Form("root_files/shms_calibration_%d.root", RunNumber));

  int num_pars = 6;
  int fit_max = 10000;
  int fit_min = -1000;

  TH1F *hgc_e[4][4];
  TH1F *hgc_pi[4][4];
  TH1F *hgc_full[4];
  TH1F *hgc_conv[4];
  TH1F *hgc_background[4];
  TH1F *hgc_conv_noback[4];
  TH1F *hgc_conv_mk2[4];
  TH1F *hgc_conv_noback_mk2[4];
  
  for (Int_t i=0; i<4; i++)
    {
      for (Int_t j=0; j<4; j++)
	{
	  hgc_e[i][j] = (TH1F*)F->Get(Form("phgc_quad%d_pulseInt_e%d", i+1, j+1));
	  hgc_e[i][j]->Rebin(10);
	  hgc_pi[i][j] = (TH1F*)F->Get(Form("phgc_quad%d_pulseInt_pi%d", i+1, j+1));
	  hgc_pi[i][j]->Rebin(10);
	}
      hgc_full[i] = (TH1F*)F->Get(Form("phgc_adcPulseInt%d", i+1));
      hgc_full[i]->Rebin(10);
    }
  TF1 *l1 = new TF1("l1",linear,0,4,2);
  l1->SetParNames("Slope", "Intercept");

  TF1 *p1 = new TF1("p1",poisson,4,20,2);
  p1->SetParNames("Amplitude", "Mean");

  TF1 *f1 = new TF1("f1",gauss,0.5,3.5,9);
  f1->SetParNames("Amplitude 1"," Mean 1","Std. Dev. 1","Amplitude 2","Mean 2","Std. Dev. 2","Amplitude 3","Mean 3","Std. Dev. 3");

  TF1 *Gauss3 = new TF1("Gauss3",gauss,fit_min,fit_max,9);
  Gauss3->SetParNames("Ped Amp","Ped Mean","Ped Std. Dev.","Amplitude 1","Mean 1","Std. Dev. 1","Amplitude 2","Mean 2","Std. Dev. 2");

  TF1 *Gauss2 = new TF1("Gauss2",gauss,fit_min,fit_max,6);
  Gauss2->SetParNames("Ped Amp","Ped Mean","Ped Std. Dev.","Amplitude 1","Mean 1","Std. Dev. 1");

  TF1 *Gauss1 = new TF1("Gauss1",gauss,fit_min,fit_max,3);
  Gauss1->SetParNames("Amplitude","Mean","Std. Dev.");

  Double_t mean_1[6];
  Double_t mean_2[3];
  Double_t x_npe[3], y_npe[3], x_err[3], y_err[3];
  Double_t calibration[4], calibration_mk2[4];
  
  TSpectrum *s = new TSpectrum(2);

  gStyle->SetOptFit(111);


  //Main loop for calibration
  for (Int_t i=0; i<4; i++)
    {
      //Examining the single photoelectron (SPE) peak 
      for (Int_t n=0; n<3; n++)
	{
	  mean_1[n] = 0;
	  mean_2[n] = 0;
	  x_npe[n] = 0, y_npe[n] = 0, x_err[n] = 0, y_err[n] = 0;
	}

      TCanvas *cuts_i = new TCanvas(Form("cuts_%d",i), Form("First Photoelectron peaks for e & pions PMT%d",i+1));
      cuts_i->Divide(2,3);
      Int_t k = 1;
      for (Int_t j=0; j<4; j++)
	{
	  if (j == i) continue;
	  cuts_i->cd(k);
	  cuts_i->cd(k)->SetLogy();

	  //Peak Finder for parameter guesses
	  s->Search(hgc_e[j][i], 2.5, "nobackground", 0.001);
	  TList *functions = hgc_e[j][i]->GetListOfFunctions();
	  TPolyMarker *pm = (TPolyMarker*)functions->FindObject("TPolyMarker");
	  Double_t *xpeaks = pm->GetX();

	  //Fit the Pedistal
	  /*
	  Gauss1->SetParameters(1000., xpeaks[0], 100.);
	  Gauss1->SetParLimits(0, 0., 1000000.);
	  Gauss1->SetParLimits(1, xpeaks[0]-30., xpeaks[0]+30.);
	  Gauss1->SetParLimits(2, 1., 200.);
	  hgc_e[j][i]->Fit("Gauss1","RQNsame");
	  */
	  //Fit the first SPE for electrons
	  /*
	  Gauss2->SetParameters(Gauss1->GetParameter(0), xpeaks[0], Gauss1->GetParameter(2), Gauss1->GetParameter(0)*0.1, xpeaks[1], Gauss1->GetParameter(2));
	  Gauss2->SetParLimits(0, Gauss1->GetParameter(0)-100, Gauss1->GetParameter(0)+100);
	  Gauss2->SetParLimits(1, xpeaks[0]-30, xpeaks[0]+30);
	  Gauss2->SetParLimits(2, Gauss1->GetParameter(2)-10, Gauss1->GetParameter(2)+10);
	  Gauss2->SetParLimits(3, 0., Gauss1->GetParameter(0)+1);
	  Gauss2->SetParLimits(4, xpeaks[1]-10, xpeaks[1]+10);
	  Gauss2->SetParLimits(5, Gauss1->GetParameter(2), Gauss1->GetParameter(2)+200);
	  */
	  Gauss1->SetRange(xpeaks[1]-100, xpeaks[1]+100);
	  Gauss1->SetParameter(1, xpeaks[1]);
	  Gauss1->SetParameter(2, 200.);
	  Gauss1->SetParLimits(0, 0., 2000.);
	  Gauss1->SetParLimits(1, xpeaks[1]-200, xpeaks[1]+200);
	  Gauss1->SetParLimits(2, 10., 500.);
	  hgc_e[j][i]->Fit("Gauss1","RQN");
	  Gauss1->SetParLimits(1, Gauss1->GetParameter(1)-50, Gauss1->GetParameter(1)+50);
	  Gauss1->SetRange(Gauss1->GetParameter(1)-1.5*Gauss1->GetParameter(2), Gauss1->GetParameter(1)+1.5*Gauss1->GetParameter(2));
	  //Gauss1->SetRange(Gauss1->GetParameter(1)-1.0*Gauss1->GetParameter(2), Gauss1->GetParameter(1)+1.0*Gauss1->GetParameter(2));
	  hgc_e[j][i]->Fit("Gauss1","RQ");
	  if (xpeaks[1] != 0.0 && hgc_e[j][i]->GetBinContent(hgc_e[j][i]->GetXaxis()->FindBin(xpeaks[1])) > 90) mean_1[(k/2)] = Gauss1->GetParameter(1);
	  if (xpeaks[1] != 0.0 && hgc_e[j][i]->GetBinContent(hgc_e[j][i]->GetXaxis()->FindBin(xpeaks[1])) > 15) mean_2[(k/2)] = Gauss1->GetParameter(1);
	  gPad->Update();

	  //Repeat for pions
	  cuts_i->cd(k+1);
	  cuts_i->cd(k+1)->SetLogy();

	  //Peak finder for parameter guess
	  s->Search(hgc_pi[j][i], 2.5, "nobackground", 0.001);
	  TList *functions = hgc_pi[j][i]->GetListOfFunctions();
	  TPolyMarker *pm = (TPolyMarker*)functions->FindObject("TPolyMarker");
	  Double_t *xpeaks = pm->GetX();

	  //Fit the Pedistal
	  /*
	  Gauss1->SetParameters(1000., 0., 100.);
	  Gauss1->SetParLimits(0, 0., 1000000.);
	  Gauss1->SetParLimits(1, -10., 100.);
	  Gauss1->SetParLimits(2, 1., 200.);
	  hgc_pi[j][i]->Fit("Gauss1","RQNsame");
	  */

	  //Fit the first SPE for pions
	  /*
	  Gauss2->SetParameters(Gauss1->GetParameter(0), Gauss1->GetParameter(1), Gauss1->GetParameter(2), Gauss1->GetParameter(0)*0.1, Gauss1->GetParameter(1)+100, Gauss1->GetParameter(2));
	  Gauss2->SetParLimits(0, Gauss1->GetParameter(0)-100, Gauss1->GetParameter(0)+100);
	  Gauss2->SetParLimits(1, Gauss1->GetParameter(1)-10, Gauss1->GetParameter(1)+10);
	  Gauss2->SetParLimits(2, Gauss1->GetParameter(2)-10, Gauss1->GetParameter(2)+10);
	  Gauss2->SetParLimits(3, 0., Gauss1->GetParameter(0)+1);
	  Gauss2->SetParLimits(4, Gauss1->GetParameter(1)+100, Gauss1->GetParameter(1)+600);
	  Gauss2->SetParLimits(5, Gauss1->GetParameter(2), Gauss1->GetParameter(2)+200);
	  hgc_pi[j][i]->Fit("Gauss2","RQsame");
	  */
	  Gauss1->SetRange(xpeaks[1]-100, xpeaks[1]+100);
	  Gauss1->SetParameter(1, xpeaks[1]);
	  Gauss1->SetParameter(2, 200.);
	  Gauss1->SetParLimits(0, 0., 2000.);
	  Gauss1->SetParLimits(1, xpeaks[1]-50, xpeaks[1]+50);
	  Gauss1->SetParLimits(2, 10., 500.);
	  hgc_pi[j][i]->Fit("Gauss1","RQ");
	  if (xpeaks[1] != 0.0 && hgc_pi[j][i]->GetBinContent(hgc_pi[j][i]->GetXaxis()->FindBin(xpeaks[1])) > 100) mean_1[(k/2)] = Gauss1->GetParameter(1);
	  gPad->Update();

	  k += 2;
	}

      //Scale full ADC spectra according to SPE
      Int_t nbins;
      nbins = hgc_full[i]->GetXaxis()->GetNbins();
      Double_t m = 0.0;
      Double_t xscale = 0.0;
      for (Int_t n = 0; n < 6; n++)
	{
	  if (mean_1[n] == 0.0) continue;
	  //cout << mean_1[n] << endl;
	  xscale += mean_1[n];
	  m += 1.0;
	}
      //cout << m << endl;
      if (m == 0.0) 
	{  /*
	  for (Int_t n = 0; n < 3; n++)
	    {
	      cout << mean_2[n] << endl;
	      if (mean_2[n] == 0.0) continue;
	      xscale += mean_2[n];
	      m += 1.0;
	    }
	    xscale = xscale/m;//*/
	  ///*
	  TCanvas *low_stats_i = new TCanvas(Form("low_stats_%d",i),Form("Low stats analysis for PMT%d",i+1));
	  s->Search(hgc_full[i], 2.0, "nobackground", 0.001);
	  TList *functions = hgc_full[i]->GetListOfFunctions();
	  TPolyMarker *pm = (TPolyMarker*)functions->FindObject("TPolyMarker");
	  Double_t *xpeaks = pm->GetX();
	  Gauss1->SetRange(xpeaks[1]-100, xpeaks[1]+100);
	  Gauss1->SetParameter(1, xpeaks[1]);
	  Gauss1->SetParameter(2, 200.);
	  Gauss1->SetParLimits(0, 0., 2000.);
	  Gauss1->SetParLimits(1, xpeaks[1]-50, xpeaks[1]+50);
	  Gauss1->SetParLimits(2, 10., 500.);
	  hgc_full[i]->Fit("Gauss1","RQ");
	  xscale = Gauss1->GetParameter(1);//*/
	}
      else xscale = xscale/m;
      //cout << xscale << endl;
      hgc_conv[i] = new TH1F(Form("hgc_conv_%d", i+1), Form("Scaled ADC spectra for PMT%d",i+1), nbins, hgc_full[i]->GetXaxis()->GetXmin()/xscale,hgc_full[i]->GetXaxis()->GetXmax()/xscale);
      for (Int_t k=0; k<nbins; k++)
	{
	  Double_t y = hgc_full[i]->GetBinContent(k);
	  Double_t x = hgc_full[i]->GetXaxis()->GetBinLowEdge(k);
	  hgc_conv[i]->SetBinContent(k,y);
	}
      //And normalize the heights
      hgc_conv[i]->Scale(1.0/hgc_conv[i]->Integral(), "width");

      //TCanvas *ADCspectra_i = new TCanvas(Form("ADCspectra_%d",i), Form("Scaled ADC pulseInt spectra for PMT%d",i+1));
      p1->SetParameter(0, 5.5);
      p1->SetParameter(1, 0.25);
      hgc_conv[i]->Fit("p1","RQN");
      gPad->Update();

      hgc_background[i] = new TH1F(Form("hgc_background_%d", i+1), Form("Scaled ADC spectra background for PMT%d",i+1), nbins, hgc_full[i]->GetXaxis()->GetXmin()/xscale,hgc_full[i]->GetXaxis()->GetXmax()/xscale);
      hgc_conv_noback[i] = new TH1F(Form("hgc_conv_noback_%d", i+1), Form("Scaled ADC spectra background removed for PMT%d",i+1), nbins, hgc_full[i]->GetXaxis()->GetXmin()/xscale,hgc_full[i]->GetXaxis()->GetXmax()/xscale);
      for (Int_t l=0; l<nbins; l++)
	{
	  Double_t y = p1->Eval(hgc_conv[i]->GetXaxis()->GetBinCenter(l));
	  Double_t y2 = hgc_conv[i]->GetBinContent(l) - y;
	  hgc_background[i]->SetBinContent(l,y);
	  hgc_conv_noback[i]->SetBinContent(l,y2);
	}
      TCanvas *Final_Spectra_i = new TCanvas(Form("Final_Spectra_%d",i), Form("Scaled ADC pulseInt spectra Background Removed for PMT%d",i+1)); 
      Final_Spectra_i->Divide(2,1);
      Final_Spectra_i->cd(1);
      f1->SetParameters(0.08, 1.0, 0.22, 0.029, 2, 0.5, 0.15, 3, 0.26);
      f1->SetParLimits(1, 0.5, 1.5);
      f1->SetParLimits(2, 0.0, 1.0);
      f1->SetParLimits(3, 0.0, 1.0);
      f1->SetParLimits(4, 1.5, 2.5);
      f1->SetParLimits(5, 0.2, 0.6);
      f1->SetParLimits(6, 0.0, 1.0);
      f1->SetParLimits(7, 2.5, 3.5);
      f1->SetParLimits(8, 0.2, 0.5);
      hgc_conv_noback[i]->Fit("f1","RQ");
      hgc_conv_noback[i]->GetXaxis()->SetRangeUser(0,5);
      gPad->Update();

      y_npe[0] = f1->GetParameter(1), y_npe[1] = f1->GetParameter(4), y_npe[2] = f1->GetParameter(7);
      y_err[0] = f1->GetParError(1), y_err[1] = f1->GetParError(4), y_err[2] = f1->GetParError(7);
      x_npe[0] = 1, x_npe[1] = 2, x_npe[2] = 3;
      gr_npe = new TGraphErrors(3, x_npe, y_npe, x_err, y_err);
      //TCanvas *Linear_i = new TCanvas(Form("Linear_%d",i), Form("Verification of Linear Relationship for PMT%d",i+1));
      Final_Spectra_i->cd(2);
      l1->SetParameters(1.0, 0.0);
      gr_npe->Fit("l1","RQ");
      gr_npe->Draw("A*");
      gPad->Update();
      calibration[i] = xscale;

      Double_t xscale_mk2 = xscale * l1->GetParameter(0);
      hgc_conv_mk2[i] = new TH1F(Form("hgc_conv_mk2_%d", i+1), Form("Scaled ADC spectra mk2 for PMT%d",i+1), nbins, hgc_full[i]->GetXaxis()->GetXmin()/xscale_mk2,hgc_full[i]->GetXaxis()->GetXmax()/xscale_mk2);
      for (Int_t k=0; k<nbins; k++)
	{
	  Double_t y = hgc_full[i]->GetBinContent(k);
	  Double_t x = hgc_full[i]->GetXaxis()->GetBinLowEdge(k);
	  hgc_conv_mk2[i]->SetBinContent(k,y);
	}
      hgc_conv_mk2[i]->Scale(1.0/hgc_conv_mk2[i]->Integral(), "width");

      //TCanvas *ADCspectra_mk2_i = new TCanvas(Form("ADCspectra_mk2_%d",i), Form("Scaled ADC pulseInt spectra mk2 for PMT%d",i+1));
      p1->SetParameter(0, 5.5);
      p1->SetParameter(1, 0.25);
      hgc_conv_mk2[i]->Fit("p1","RQN");
      gPad->Update();

      hgc_conv_noback_mk2[i] = new TH1F(Form("hgc_conv_noback_mk2_%d", i+1), Form("Scaled ADC spectra background removed mk2 for PMT%d",i+1), nbins, hgc_full[i]->GetXaxis()->GetXmin()/xscale_mk2,hgc_full[i]->GetXaxis()->GetXmax()/xscale_mk2);
      for (Int_t l=0; l<nbins; l++)
	{
	  Double_t y = p1->Eval(hgc_conv_mk2[i]->GetXaxis()->GetBinCenter(l));
	  Double_t y2 = hgc_conv_mk2[i]->GetBinContent(l) - y;
	  hgc_conv_noback_mk2[i]->SetBinContent(l,y2);
	}

      TCanvas *Final_Spectra_mk2_i = new TCanvas(Form("Final_Spectra_mk2_%d",i), Form("Scaled ADC pulseInt spectra Background Removed mk2 for PMT%d",i+1)); 
      Final_Spectra_mk2_i->Divide(2,1);
      Final_Spectra_mk2_i->cd(1);
      
      f1->SetParameters(0.08, 1.0, 0.22, 0.029, 2, 0.5, 0.15, 3, 0.26);
      f1->SetParLimits(1, 0.5, 1.5);
      f1->SetParLimits(2, 0.0, 1.0);
      f1->SetParLimits(3, 0.0, 1.0);
      f1->SetParLimits(4, 1.5, 2.5);
      f1->SetParLimits(5, 0.2, 0.6);
      f1->SetParLimits(6, 0.0, 1.0);
      f1->SetParLimits(7, 2.5, 3.5);
      f1->SetParLimits(8, 0.2, 0.5);
      
      //f1->SetParameters(0.15, 1.02, 0.3, 0.07, 2.06, 0.4, 0.04, 3.2, 0.5);
      hgc_conv_noback_mk2[i]->DrawCopy();
      hgc_conv_noback_mk2[i]->Fit("f1","RQsame");
      hgc_conv_noback_mk2[i]->GetXaxis()->SetRangeUser(0,5);
      //f1->Draw("same");
      gPad->Update();

      y_npe[0] = f1->GetParameter(1), y_npe[1] = f1->GetParameter(4), y_npe[2] = f1->GetParameter(7);
      y_err[0] = f1->GetParError(1), y_err[1] = f1->GetParError(4), y_err[2] = f1->GetParError(7);
      x_npe[0] = 1, x_npe[1] = 2, x_npe[2] = 3;
      gr_npe_mk2 = new TGraphErrors(3, x_npe, y_npe, x_err, y_err);
      Final_Spectra_mk2_i->cd(2);
      l1->SetParameters(1.0, 0.0);
      gr_npe_mk2->Fit("l1","RQ");
      gr_npe_mk2->Draw("A*");
      gPad->Update();
      calibration_mk2[i] = xscale_mk2;
    }
  cout << "Calibration constants are: " << endl;
  for (Int_t i=0; i<4; i++)
    {
      cout << Form("PMT%d: ",i+1) << calibration[i] << "  " << calibration_mk2[i] << endl;
    }
}
