macro runRICH dirn=G064_Q1000_H013_2 head='rich' _
              i0=1 i1=64 fntrail=.txt xmin=-25 xmxln=1270 xmxlg=1570 refit='none'
  fnhead = [head]_[dirn].
  exec fit_b [i0] [i1] 'VB' [refit] [dirn] [fnhead] [fntrail]
  exec allpl_b [i0] [i1] [dirn] [fnhead] [fntrail] [xmin] [xmxln] [xmxlg]
return
*
macro fitRICH dirn=G064_Q1000_H013_2 head='rich' _
              i0=1 i1=64 fntrail=.txt xmin=-25 xmxln=1270 xmxlg=1570 refit='none'
  fnhead = [head]_[dirn].
  exec fit_b [i0] [i1] 'VB' [refit] [dirn] [fnhead] [fntrail]
return
*
macro plotRICH dir=WEB0 fname=test.dat head='richtree' _
               i0=1 i1=1 fntrail=.txt xmin=-25 xmxln=470 xmxlg=620
  dirn = [dir]_[fname]; fnhead = [head]_[dirn].
  exec allpl_b [i0] [i1] [dirn] [fnhead] [fntrail] [xmin] [xmxln] [xmxlg] [fname]
return
*
macro gopl filn=639.dat id=639 dir=k1 fpar=k1/hist4639.dat9.parerr _
 jl=4 jr=3 frbin=1 tobin=520 ll=log fidv=k1/hist4639.dat9.idvec _
 xsmin=-50 xsmax=450 fnhead=hist4 fname=test.dat
*
  filecase keep; exec pl
  if $vexist(compile) = 0 then
    ve/cr par(11) r; ve/cr err(11) r; ve/cr parg(3) r; ve/cr errg(3) r; ve/cr idvec(4) r 
    ve/cr compile(1) r
    exec ../../pmtfit/comisSetPath.kumac
    call ../../pmtfit/ppmt11.f77(0.0)
  endif
*
  file = [fnhead][filn]; filg = [fnhead][filn]
  ve/cr vidvi(4) r; ve/read vidvi [fidv]
  nbins = vidvi(1); xmin = vidvi(2); xmax = vidvi(3); mean  = vidvi(4)
  if [nbins] = 0 goto stop | *** Error Condition ***
  ve/copy vidvi idvec; ve/del vidvi
*
  exec black; opt [ll]y
**  Graphics/Vie/Size 24 12 | *** Special size for 10 plots/page
  opt nsta; opt fit; set fit 111; opt ngri; exec setpq; opt tic; opt date
  points 1000; title ' ' u
  ttx = [fname]; title [ttx]
  ve/read par,err [fpar]
  fxnerb = [dir]/[file]11.xnerb; fchiq = [dir]/[file]11.chiq
  if $vexist(xrb) = 1 then
    ve/del xrb,nrb,exrb,enrb,chiq
  endif
  ve/read xrb,nrb,enrb [fxnerb]; ve/cr chiq(4) r; ve/read chiq [fchiq]
  iwl = $sigma(nco(xrb)); iwl = [iwl] - 1 
*
  Scale = par(1); Sigma = par(2); mu = par(3); Beta = par(10); Tau = par(11)
  x0corr = [mean] - ([Beta]*([Tau])*[Sigma]) - ([Scale]*[mu])
  wpoiss = $sigma(1.45/[scale]*exp(-[mu])*[mu])
*
  nmus = $sigma(int([mu]+3.0)) | *** Start loop on finding right edge
  nmusf = 1; munmus = 1.0
  do i = 2 , [nmus]
    nmusf  = [nmusf]*[i]    | *** nmus factorial
    munmus = [munmus]*[mu]  | *** [mu]**([nmus]-1)
  enddo
  fvlim = 0.1e-3
  if [ll] = 'lin' then
    fvlim = 0.1e-2
  endif
loopre:
   funval = $sigma([munmus]/[nmusf])
   if [funval] < [fvlim] goto refnd
   nmus   = [nmus] + 1
   nmusf  = [nmusf]*[nmus]  | *** nmus factorial
   munmus = [munmus]*[mu]   | *** [mu]**([nmus]-1)
   goto loopre
refnd:
  remax = [nmus] + 1.25; remin = -[remax]/10.
  xsmin=[remin]*[Scale]; xsmax=[remax]*[Scale] | *** Auto scale one and for all *** 
*
  if $hexist([id]) then
    hi/del [id]
  endif
  hi/fil 66 [dir]/[file]11.hbook
  hrin [id]
  clo 66
  ve/cr xw([nbins]) r; ve/cr yw([nbins]) r; ve/cr exw([nbins]) r; ve/cr eyw([nbins]) r
  REBIN [id] xw yw exw eyw [nbins] 1 [nbins]; ve/copy $sigma(diff(xw)) dxw; dx = dxw(1)
  wpoiss = [wpoiss]*[dx]; mxscale = [wpoiss]*1.75
  if [ll] = 'lin' then
    mnscale = 0.; mnvis = 0.; mxvis = 1.99
  else
    mnscale = [mxscale] * 0.1e-2; mnvis = 0.002
    mxscale = [mxscale] * 17.5;   mxvis = 50.0
  endif
  min [id] [mnscale]; max [id] [mxscale]
  set dmod 1; set hwid 1; set fwid 1
  mns1000 = [mnscale]*1000; mxs1000 = [mxscale]*1000
  xsmin0 = [xsmin]+([x0corr]); xsmax0 = [xsmax]+([x0corr])
  exec black;  null [xsmin] [xsmax] [mnvis] [mxvis]
  null [xsmin0] [xsmax0] [mnscale] [mxscale] abs; exec setsq
  atitle 's = Amplitude - Pedestal (channels ADC)' 'dN/ds p.d.f. (arb. units)' ' ' 222
*
  exec yellow
  set bwid 1
  if [ll] = 'log' then
    h/err xw yw exw eyw [nbins] 1 .001
  endif
  ve/del xw,yw,exw,eyw
  ve/copy $sigma(xrb*0.0) exrb
*
  exec black; h/err xrb nrb exrb enrb [iwl] 25 .007
  set hwid 3; set hcol 4; imax = $sigma(int([mu]*5.25)); imax = $sigma(max(5,[imax]))
  do i = 2, [imax]
   exec violet; fu/pl fplot(x,[i],[i]) [xmin] [xmax] s
  enddo
  exec white 8; set hwid 6; fu/pl fplot(x,0,16) [xmin] [xmax] s
  exec red;     set hwid 4; fu/pl fplot(x,0,16) [xmin] [xmax] s
  exec black; set mtyp 1; set hwid 1; h/err xrb nrb exrb exrb [iwl] 25 .03
  set hwid 3; set hcol 3; fu/pl fplot(x,0,0) [xmin] [xmax] s
  set dmod 2; set hwid 1; set hcol 1; fu/pl fplot(x,0,0) [xmin] [xmax] s
  set dmod 1; set hwid 3; set hcol 6; fu/pl fplot(x,1,1) [xmin] [xmax] s
  exec red;     set hwid 4; fu/pl fplot(x,0,16) [xmin] [xmax] s
  exec black; set mtyp 1; set hwid 1; h/err xrb nrb exrb exrb [iwl] 25 .017
  exec red;     set hwid 1; fu/pl fplot(x,0,16) [xmin] [xmax] s
*
  exec black;  set hwid 3; set fwid 3
*  set dmod 4; fu/pl pfplot(x,1,1,0) [xmin] [xmax] s
*  set dmod 3; fu/pl pfplot(x,1,1,1) [xmin] [xmax] s
*  set dmod 2; fu/pl pfplot(x,1,1,2) [xmin] [xmax] s
  set dmod 1
*
  exec red
  exec  notes 0.17 0.92 'Red line: ' 0. 0.5 defont
  exec snotes 0.31 0.92 'dN/ds = f?PMT!(s;? !parameters)' 0. 0.5 -50
  exec black
**
** -- Create ideal 1-ph.e. distributions function of A (A=1 corresponds to 1 ph.e)
  Eff20 = 0; Eff25 = 0; ve/copy par part; ve/copy err errt
  if [ll] = 'lin' then | *** Do not do it twice for 'lin' and for 'log'
    ncfx=1000; fxmn=-0.5; fxmx=4.5; mm=[mean]/[Scale]; ss=0.02 |** ss=[Sigma]/[Scale]
    ve/cr work(6) r [ncfx] [fxmn] [fxmx] [mm] 1.0 [ss]
    ve/copy work(1:4) idvec; ve/copy work(5:6) par(1:2); ve/del work
    norm = $sigma(exp([mu])/[mu])
    fun1 257257 [norm]*fpres(x,1,1) [ncfx] [fxmn] [fxmx] ' '
    ve/cr xfun([ncfx]) r; ve/cr exfun([ncfx]) r; ve/cr ffun([ncfx]) r; ve/cr effun([ncfx]) r
    rebin 257257 xfun ffun exfun effun [ncfx] 1 [ncfx]
    ve/write xfun,ffun [dir]/[file]11.spes '2E14.6'
    i20 = $sigma(int([ncfx]/([fxmx]-([fxmn]))*(20./[Scale]-([fxmn]))))
    i25 = $sigma(int([ncfx]/([fxmx]-([fxmn]))*(25./[Scale]-([fxmn]))))
    ve/copy ffun([i20]:[ncfx]) ffun20; Eff20 = $sigma(vsum(ffun20))
    ve/copy ffun([i25]:[ncfx]) ffun25; Eff25 = $sigma(vsum(ffun25))
    ve/del xfun,ffun,exfun,effun,ffun20,ffun25; hi/del 257257
  endif
  exec table [dir] [file] [id] [ll] 0.04 [Eff20] [Eff25]
*
stop:
return [nbins]
*
*===================== Comments =======================
* filn:    histogram data file
* id:      index (pixel#, or something else)
* dir:     directory for the file location
* fpar:    file with the parameter set (if available)
* jl:      N points to the left of the pedestal max to include in pedestal fit
* jr:      --"-- to the right --"--. The default for now is (jl,jr)=(7,4)
* fitmod:  Control word for the Minuit fits, "VB" means print results and parameters are bound 
*           (there are min and max values in each fit)
* fnhead:  prefix to the file name
* fntrail: postfix to the file name
* fitA:    extra control of the type of the fit - using averged parameter set or not
*======================================================
macro go filn=639.dat id=639 dir=k2 fpar=none jl=7 jr=2 _
         fitmod='MVB' fnhead=hist4 fntrail=.dat fitA=no
  nnbin = 500
* ===   Some initial setup   ===
  file = [fnhead][filn]; filg = [fnhead][filn]; dfile = [dir]/[file]
  filna = [filn]11.parerr
  if $fexist([dfile]) <> 1 goto abort | *** Check if the file is present ***
  gid = 100 + [id]; gtid = 200 + [id]
  opt logy; exec black; opt stat; set stat 1000100
  opt fit; set fit 111; set fcol 2; opt grid; points 1000
  opt utit; title [file]
  ve/del *
  filecase keep; exec pl
  exec ../../pmtfit/comisSetPath.kumac
  call ../../pmtfit/chiq.f77(0.0)
  clo 66
  swi g
*===================== Comments =======================
*    Call "gauss" routine 
*    Reads the data file, evaluates pedestal position, 
*    creates the histogram and the vectors for the subsequent fit
*    Returns the value of peak position (x0), parameters of the fit and Chi2
*    "s" is the evaluated sigma
*    -- See "macro gauss" below for details -- 
*======================================================
  exec gauss [filg] [jl] [jr] [gid] [dir] [file] [gtid] 6000 [nnbin]
  x0 = [@]
  if [x0] = -1000000 goto stop | *** Error condition from 'gauss' ***
  Afit = parg(1); s = parg(3); Chi2g = chi2(1)
  mess 'Chi2g = '[Chi2g]
***goto stop
  swi gz
  if $hexist([id]) then
    hi/del [id]
  endif
* === Get information line about this PMT ===
* === check if it's CA or ZA type, to select some initial parameter values ===
  ve/cr info(7) r; ve/read info(1:7) [dir]/ID_infoline
  PMTType = info(2); ve/del info
*  if [PMTType] < 0.5 then | "CA"
    Nu2Base = 0.150;  XiBase = 14.
    nu2min = 0.050;  nu2bmn = 0.120
    a2min = 0.050;   a2bmn = 0.225
*  else
*    Nu2Base = 0.210;  XiBase = 15.5
*    nu2min = 0.120;  nu2bmn = 0.190
*    a2min = 0.050;   a2bmn = 0.225
*  endif 
* === Read the data file and do 'vflush' ===
* === It was already done in 'gauss' - but this repetition is for the case when ===
* === the data file for the pedestal is different from the main data file === 
  ve/read xraw,n [dir]/[file] ! 'OC' -/h10/(*); exec vflush vx=xraw vy=n nnbin=[nnbin]
  if $vexist(xraw) = 0 then
    mess ' *** FATAL ERROR in reading the input file! Terminating...'
    goto stop
  endif
  nbins = $sigma(nco(xraw))
  if [nbins] < 10 then
    mess ' *** FATAL: Too few points in the input file! Terminating...'
    goto stop
  endif
*
* === Shift the data such that pedestal max is at zero, and update 'x0' to zero
  ve/copy $sigma(xraw-([x0])) x; x0 = 0.
  nbins = $sigma(nco(x))
  ve/copy $sigma(diff(x)) dxbin
* === Set up proper limits for the histogram to have all 'x' values to be in the middle of the bins ===
  dx = dxbin(1); xmin = x(1) - 0.5*[dx]; xmax = x([nbins]) + 0.5*[dx]
* === Setting integer intervals around the pedestal max ===
* === 'i1' - will be the first bin included in the fitting procedure ===
* === 'ii0' and 'ii1' - limits used to count events in the peak ===
  i1  = $sigma(max(1,int(([x0]-2.5*[s]-([xmin]))/[dx])))
  ii0  = $sigma(max(1,int(([x0]-5.5*[s]-([xmin]))/[dx])))
  ii1  = $sigma(min([nbins],int(([x0]+20.*[s]-([xmin]))/[dx])))
  iirt = $sigma(min([nbins],int(([x0]-([xmin]))/[dx])+[jr]))
  if [iirt] > [ii1] then
    ii1 = [iirt]
  endif
  Ngamn = $hinfo([gid],'xbins'); ve/cr vgamn([Ngamn]) r; get/cont [gid] vgamn
  lpeak = [ii1] - [ii0] + 1; ve/cr peaksum([lpeak]) r
* === Select peak area +/- 5.5 sigma around max and calculate event sum in it ===
  ve/copy vgamn([ii0]:[ii1]) peaksum; SPS = $sigma(vsum(peaksum))
  ve/del vgamn,peaksum
* === Clean the histogram to the left of the [ii0] to avoid the skewed 'mean'
  if [ii0] > 3 then
    nii0 = [ii0] - 3; ve/cr nzero([nii0]) r; ve/copy nzero n(1:[nii0]); ve/del nzero
  endif
*
  if $hexist([id]) then
    hi/del [id]
  endif
* === Creating the [id] histogram, using right limits in 'x' and the 'n' values from the raw data file === 
  1d [id] [file] [nbins] [xmin] [xmax] 0.
  put/cont [id] n; call hbarx([id])
*
* === Calculate nsum not relying on HBOOK here because the peak may overwhelm arithmetic ===
** nsum = $sigma(vsum(n))
  nsum = 0.
  do im = [nbins] , 1 , -1 | *** The nsum is calculated backwards ***
    nsum = [nsum] + n([im])
  enddo
  weight = 1./[nsum]
* === Normalization to the unit sum
  add [id] [id] [id] 0. [weight]
* === Calculate mean not relying on HBOOK here because the peak may overwhelm arithmetic ===
**  mean = $hinfo([id],'mean')
  mean = 0.
  do im = [nbins] , [ii1] , -1 | *** The Mean is calculated excluding the peak ***
    mean = [mean] + x([im])*n([im])
  enddo
  mean = [mean]/[nsum]
  if [mean] < 0. then | *** The impossible [mean] ***
    mean = -[mean]
  elseif [mean] = 0. then 
    mean = [s]
  endif
  rms = $hinfo([id],'rms')
  mess ' Mean = '[mean]; mess ' RMS = '[rms]
*
* === Setting up the initial values for the parameters ===
* === The range and initial values for 'Nu2' are different for 'CA' and 'GA/ZA' PSPMTs ===
* -- Mu based on the integral under the Gaussian
  Mu = $sigma(-log([SPS])) | -- Zero's channel of the Poisson
  Scale = [s]
  if [Mu] > 0 then
    Scale = [mean]/[Mu]
  else
    Mu = 0.1e-4
  endif
*
* --- Chi2g = 1.  for 'normal' fit
* --- Chi2g <> 1. to adjust pedestal errors such that a Gaussian fits it with Chi2 = 1 
*#*#*  if [Chi2g] < 1. then
*#*#*    Chi2g = 10.
*#*#*  endif
* === Re-binning the histogram to average bins with low statistics, ===
* === and make the stat. error adjustment for the pedestal Gaussian ===
* === if the original pedestal fit produced bad Chi2/NDF
  exec rebinb [x0] [s] [xmin] [dx] [nbins] [weight] [Chi2g] -1 [jr]
* === Returns number of elements in the fit vector ===
  iwl = [@] - 1
* === Also returns bin limits for the pedestal peak ===
  plimL = peaklim(1); plimR = peaklim(2); ve/del peaklim

  Nu1 = 10.5; a2 = 0.25; Nu2 = [Nu2Base]; a3 = 0.25; Nu3 = 0.57; Xi = [XiBase]; Sigma=[s]
*  Beta = 0.001	 ; Tau = 0.7
*  Beta = 0.001	 ; Tau = 5.5 | *** For the MAROC runs
**  Beta = 0.01	 ; Tau = 2.0 | *** For the rebinned runs
  Beta = 0.7*[Mu]; Tau = 0.01*[Scale]/[s] | *** For the rebinned runs
* 
  mess 'Mu initial = '[Mu]
  mess 'Scale initial = '[Scale]
  mess 'Sigma initial = '[Sigma]
*
  mean = 0.
  do im = [nbins] , 1 , -1 | *** The Mean is re-calculated including the peak ***
    mean = [mean] + x([im])*n([im])
  enddo
  mean = [mean]/[nsum]
  mess ' Recalculated mean = '[mean]
*
* === Create vectors 'par' and 'idvec' and compile the code === 
  ve/cr par(11) r; ve/cr idvec(4) r [nbins] [xmin] [xmax] [mean]
  call ../../pmtfit/ppmt11.f77(0.0) | *** need to compile after vectors are ready ***
*
* === Set of vectors needed for the fit ===
  ve/cr par11(11) r [Scale] [Sigma] [Mu]   [Nu1]  [a2]   [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/cr   stp(11) r 1.0     0.000   0.0001  0.0    0.0   0.0     0.0   0.00  0.0  0.0    0.0
  ve/cr   pmn(11) r 1.0     2.7     0.1e-4  7.5 [a2bmn] [nu2bmn] 0.05  0.32  0.91 0.0    1.0
  ve/cr   pmx(11) r 1000.   12.7    25.0   22.5    0.75  0.32    0.57  0.75 22.5  0.5   20.0
  ve/cr   err(11) r; ve/copy par11 par
  if $fexist([fpar]) = 0 then
    fpar = 'none'
  endif
* === Fit logic: selection between starting from scratch, continuing from previous fit, fit using   ===
* === averaged parameters, or performing 'final fine fit'; this is historically ugly again, sorry. ===
* === For the clean start from scratch, 'fpar' = none, and the first fit is done using the initial ===
* === values with only Scale and Mu variables, then the series continues after the 'endif' ===
  if [fpar] = 'none' then
    exec FineLim Nu2lmn=[nu2bmn]
    exec ScMuLim
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
*    exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*    goto endfit
  elseif [fitA] = 'no' then
    ve/read par11,err11 [fpar]; ve/copy par11(1:11) par(1:11)
    goto finfit
  elseif [fpar] = 'avrg' then | *** Fit with fixed a2,Nu2,a3,Nu3,Xi
    ve/read par11,err11 [fpar]; ve/copy par11(1:11) par(1:11)
* First adjust Nu1 
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 0.0    0.0     0.000  1.00   0.00   0.00   0.0   0.0  0.0  0.00   0.00
    ve/del pmn; ve/cr pmn(11) r 1.0    0.6     0.1e-4 7.5    0.05 [nu2bmn] 0.05  0.32 0.91 0.0    0.02
    ve/del pmx; ve/cr pmx(11) r 1000.  2.7     25.0   22.5    0.75   0.27   0.57  0.75 22.5 0.2    0.75
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]  11 par stp pmn pmx err
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 1.0    0.0     0.001  0.00   0.00  0.00   0.00  0.00   0.0  0.0   0.0
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 1.0    0.0     0.001  1.00   0.00  0.00   0.00  0.00   0.0  0.0   0.0
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]  11 par stp pmn pmx err
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 1.0    0.10    0.001  1.00   0.00  0.00   0.00  0.00   0.0  0.0   0.0
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]  11 par stp pmn pmx err
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
    goto endfit
  else | *** Fit with fixed Nu1,a2,Nu2,a3,Nu3,Xi
    ve/read par11,err11 [fpar]; ve/copy par11(1:11) par(1:11)
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 0.1    0.0     0.001  0.00   0.00   0.00   0.0   0.0  0.0  0.00   0.00
    ve/del pmn; ve/cr pmn(11) r 1.0    0.6     0.1e-4 7.5 [a2min] [nu2min] 0.05  0.32 0.91 0.0    0.02
    ve/del pmx; ve/cr pmx(11) r 1000.  2.7     25.0  22.5    0.75   0.27   0.57  0.75 22.5 0.2    12.0
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]  11 par stp pmn pmx err
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 0.1    0.10    0.000  0.00   0.00  0.00   0.00  0.00   0.0  0.0   0.0
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 0.1    0.01    0.001  0.00   0.00  0.00   0.00  0.00   0.0  0.0   0.0
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]  11 par stp pmn pmx err
    exec FineLim Nu2lmn=[nu2min] 
    exec ScMuLim
*                              [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
    ve/del stp; ve/cr stp(11) r 0.1    0.01    0.001  0.00   0.00  0.00   0.00  0.00   0.0  0.0   0.0
    ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
    goto endfit
  endif
*
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.10    0.001  0.00   0.00  0.00   0.00  0.00   0.0  0.0   0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 0.000  0.00    0.000  1.00   0.00  0.00   0.00  0.01  0.00  0.0   0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 0.000  0.000   0.000  1.00   0.01  0.00   0.00  0.00  0.00  0.0   0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.00  0.00   0.00  0.00  0.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.00    0.001  1.00   0.01  0.00   0.01  0.01  0.00  0.0   0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.01  0.00   0.01  0.01  0.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.100   0.001  0.00   0.01  0.01   0.00  0.00  0.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.01  0.01   0.01  0.01  0.00  0.0   0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi*] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  0.00   0.00  0.00   0.00  0.00  1.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*
  ve/del pmn; ve/cr pmn(11) r 10.0   0.6     0.1e-4 7.5 [a2min] [nu2min] 0.05 0.37  0.91 0.00   0.02
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.00  0.00   0.00  0.00  0.00  0.0   0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2bmn]
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 0.0    0.00    0.000  1.00   0.01  0.01   0.01  0.01  0.00  0.0   0.0
***  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim 0.5 1.5 Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.01  0.01   0.01  0.01  0.00  0.00  0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi*] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.00  0.00   0.00  0.00  1.00  0.00  0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim 0.5 1.5 Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 0.0    0.00    0.000  1.00   0.01  0.00   0.01  0.01  0.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*
  exec FineLim Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi*] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 0.0    0.00    0.000  1.00   0.01  0.01   0.01  0.01  1.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.01  0.00   0.01  0.00  0.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
***  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
***  goto endfit
*  
finfit:
*
  ve/del pmn; ve/cr pmn(11) r 10.0   0.6     0.1e-4 7.5 [a2min] [nu2min] 0.05 0.37  0.91 0.00   0.02
  exec FineLim Nu2lmn=[nu2min] 
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.00  0.00   0.00  0.00  0.00  0.0   0.0
***  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2min] 
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.100   0.001  1.00   0.00  0.00   0.00  0.00  0.00  0.0   0.0
***  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2min] 
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi*] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 0.0    0.00    0.000  1.00   0.00  0.00   0.01  0.01  1.00  0.0   0.0
***  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
*
  exec FineLim Nu2lmn=[nu2min] 
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta*] [Tau*]
  ve/del stp; ve/cr stp(11) r 0.0    0.000   0.000  0.00   0.01  0.01   0.00  0.00  0.00  0.001   0.1
***##  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2min] 
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta*] [Tau*]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.00  0.00   0.00  0.00  0.00  0.001   0.1
***##  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
*  goto endfit
  exec FineLim Nu2lmn=[nu2min] 
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 0.0    0.00    0.000  1.00   0.01  0.01   0.01  0.01  0.00  0.0   0.0
***  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
*  goto endfit
  exec FineLim Nu2lmn=[nu2min] 
  exec ScMuLim
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta*] [Tau*]
  ve/del stp; ve/cr stp(11) r 1.0    0.001   0.001  1.00   0.01  0.01   0.01  0.01  1.00  0.001   0.1
***##  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
  goto endfit
  exec FineLim 0.5 1.5 Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.000   0.001  1.00   0.01  0.01   0.01  0.01  0.00  0.00  0.0
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
* exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
  goto endfit
*
  ve/cr work(1) r 5; ve/copy work(1:1) par(9:9)
  exec FineLim 0.5 1.5 Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.00    0.001  1.00   0.00  0.00   0.00  0.00  0.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
*  ve/del stp; ve/cr stp(11) r 1.0    0.02    0.001  1.00   0.01  0.01   0.05  0.05  1.00  0.00  0.00
*  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  exec FineLim 0.5 1.5 Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.02    0.001  1.00   0.00  0.00   0.00  0.00  1.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
  exec FineLim Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.02    0.001  1.00   0.01  0.01   0.05  0.05  1.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod] 11 par stp pmn pmx err
  goto endfit
*
  exec FineLim Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.02    0.001  1.00   0.01  0.01   0.05  0.05  1.00  0.00  0.00
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
*  goto endfit
*
  exec FineLim Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta*] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.02    0.001  1.00   0.01  0.00   0.05  0.05  0.00  0.00  0.10
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
  goto endfit
*
  exec FineLim Nu2lmn=[nu2min]
*                            [Scale] [Sigma] [Mu]   [Nu1]  [a2]  [Nu2]  [a3]  [Nu3] [Xi] [Beta*] [Tau]
  ve/del stp; ve/cr stp(11) r 1.0    0.02    0.001  1.00   0.01  0.01   0.05  0.05  0.00  0.00  0.10
  ve/fit xrb([i1]:[iwl]) nrb([i1]:[iwl]) enrb([i1]:[iwl]) ppmt11 [fitmod]E 11 par stp pmn pmx err
*  
endfit:
*
  call chiq
  fu/pl fplot(x,0,16) [xmin] [xmax] s
  hi/copy 12345 1100; hi/del 12345
  exec black
  do i = 0 , 16
    fu/pl fplot(x,[i],[i]) [xmin] [xmax] s
    idi = 1000 + [i]
    hi/copy 12345 [idi]; hi/del 12345
  enddo
  exec pink; h/err xrb nrb exrb enrb [iwl] 25 .03; exec black
  ve/write par,err [dir]/[file]11.parerr
  if  [fitA] = 'no' then
    shell mkdir -p [dir]/non-averaged
    ve/write par,err [dir]/non-averaged/[filna]
  endif
  ve/write idvec   [dir]/[file]11.idvec
  ve/write xrb,nrb,enrb [dir]/[file]11.xnerb
  ve/write chi2,vncfit,vnpfit,vnfpar [dir]/[file]11.chiq
  fhbk = [dir]/[file]11.hbook
  hi/fil 66 [fhbk] ! n
  hrout *
  clo 66
*
goto stop
abort:
  mess [dfile]
  mess ' %%% Data File Does not exist! %%%'
stop:
return
*
macro ScMuLim Flow=0.8 Fhigh=1.2
*------------ Sets min/max limits based on current par values for scale, Mu, and Nu1 -----------
  Scc = par(1); Sc0 = [Scc]*[Flow]; Sc1 = [Scc]*[Fhigh]
  ve/cr Scl(2) r [Sc0] [Sc1]; ve/copy Scl(1:1) pmn(1:1); ve/copy Scl(2:2) pmx(1:1); ve/del Scl
  Muc = par(3); Mu0 = [Muc]*[Flow]; Mu1 = [Muc]*[Fhigh]
  ve/cr Mul(2) r [Mu0] [Mu1]; ve/copy Mul(1:1) pmn(3:3); ve/copy Mul(2:2) pmx(3:3); ve/del Mul
  Nu1c = par(4); Nu10 = [Nu1c]*[Flow]; Nu11 = [Nu1c]*[Fhigh]
  ve/cr Nu1l(2) r [Nu10] [Nu11]; ve/copy Nu1l(1:1) pmn(4:4); ve/copy Nu1l(2:2) pmx(4:4); ve/del Nu1l
return
*
*-GA-*
macro FineLim Flow=0.8 Fhigh=1.2 onemx=0.95 Nu2lmn=0.017 Xilmn=2.5 Xilmx=22.5 _
      dnmx=0.1 Nu3lmn=0.22 Nu3lmx=0.77 Taulmx=20.0
*-CA-*macro FineLim Flow=0.8 Fhigh=1.2 onemx=0.95 Nu2lmn=0.05 Xilmn=2.5 Xilmx=22.5
*------------ Sets min/max limits for all parameters based on current par values -----------
  ve/copy $sigma(par*[Flow]) pmn; ve/copy $sigma(par*[Fhigh]) pmx; Nu3 = par(8)
  a2mx = pmx(5); Nu2mx = pmx(6); a3mx = pmx(7); Nu3mx = pmx(8); Ximx = pmx(9)
  betamx = pmx(10); taumx = pmx(11)
  Nu2mn = pmn(6); Nu3mn = pmn(8); Ximn = pmn(9)
  if [Nu2mn] < [Nu2lmn] then
    Nu2mn = [Nu2lmn]
  endif
  if [Nu3mn] < [Nu3lmn] then
    Nu3mn = [Nu3lmn]
  endif
  if [Ximn] < [Xilmn] then
    Ximn = [Xilmn]
  endif
  if [a2mx] > [onemx] then
    a2mx = [onemx]
  endif
  if [a3mx] > [onemx] then
    a3mx = [onemx]
  endif
  if [Nu3mx] > [Nu3lmx] then
    Nu3mx = [Nu3lmx]
  endif
  if [Ximx] > [Xilmx] then
    Ximx = [Xilmx]
  endif
  if [Taumx] > [Taulmx] then
    Taumx = [Taulmx]
  endif
  if [betamx] > 1.0 then
    betamx = 1.0
  endif
  if [betamx] < 0.0001 then
    betamx = 0.0001
  endif
  dn3mx = [Nu3] - [dnmx] | *** Avoid coincident nu2 and nu3
  if [Nu2mx] > [dn3mx] then
    Nu2mx = [dn3mx]
  endif
  ve/cr work(3) r [Nu2mn] [Nu3mn] [Ximn]; ve/copy work(1:1) pmn(6:6)
  ve/copy work(2:3) pmn(8:9); ve/del work
  ve/cr work(7) r [a2mx] [Nu2mx] [a3mx] [Nu3mx] [Ximx] [betamx] [Taumx]
  ve/copy work(1:7) pmx(5:11); ve/del work
return
*
macro ploti id0=4644 id1=0 ll=log tobin=2500 dir=k2 xmin=-50 xmax=450
  if [id1] = 0 then
    id1 = [id0]
  endif
  opt zfl; swi gz; ve/del *
  do i = [id0], [id1]
    if [i] < 10 then
      filn = 0[i].dat
    else
      filn = [i].dat
    endif
    file = hist4[filn]
    fil11 = [dir]/[file]11.parerr; fiv11 = [dir]/[file]11.idvec
    exec gopl [filn] [i] [dir] [fil11] 12 2 1 [tobin] [ll] [fiv11] [xmin] [xmax]
  enddo
return
*
macro fit_b id0=1 id1=64 fitmod='VB' fpar='none' dir=data01 fnhead=richtree_ZA0014. fntrail=.dat
  maxjobs = 64
  shell rm -f  paw_[dir] 
  shell rm -rf fit_[dir]
  shell mkdir  fit_[dir]
  shell ln -s $MCWORKS/paw/pawX11 paw_[dir]
  if [id1] = 0 then
    id1 = [id0]
  endif
  opt zfl; swi gz; ve/del *
  if [maxjobs] < 2 .or. [id1] = [id0] then
    do i = [id0], [id1]
      for/fil 72 fit_[dir]/[fnhead][i]; clo 72
      exkumf = [dir]/r[i].kumac; exlogf = [dir]/r[i].log
      exline = 'exec ../../pmtfit/webfit11#fit_i '_
//[i]//' '//[i]//' '//[fitmod]//' '//[fpar]//' '//[dir]_
//' '//[fnhead]//' '//[fntrail]//' 1 3'
      shell echo [exline]   > [exkumf]
      shell echo ' exit'   >> [exkumf]
      shell nice ./paw_[dir] -b [exkumf] >& [exlogf] 
    enddo
  else
    j0 = [id0]; jfree = [maxjobs]
jobloop:
    j1 = [j0]+[jfree]-1; j1 = $sigma(min([j1],[id1]))
    do i = [j0], [j1]
      for/fil 72 fit_[dir]/[fnhead][i]; clo 72
      exkumf = [dir]/[fnhead][i].kumac; exlogf = [dir]/[fnhead][i].log
      exline = 'exec ../../pmtfit/webfit11#fit_i '_
//[i]//' '//[i]//' '//[fitmod]//' '//[fpar]//' '//[dir]_
//' '//[fnhead]//' '//[fntrail]//' 1 3'
      shell echo [exline]   > [exkumf]
      shell echo ' exit'   >> [exkumf]
      shell nice ./paw_[dir] -b [exkumf] >& [exlogf] &
    enddo
    exec feedpaw fit_[dir] [maxjobs] [j1] [id1]
    j0 = [j1] + 1; jfree = [@]; if [j1] < [id1] goto jobloop 
  endif
  shell rm ./paw_[dir]
  shell rm -r ./fit_[dir]
  shell rm -f ./ppmt11_*.f ./ppmt11_*.sl chiq_*.f chiq_*.sl
return
*
macro feedpaw dir=directory maxj=8 j1=8 id1=64
  command = 'ls -1 '//[dir]//' | wc -l'
loop:
  wait ' ' 1; nproc = $shell([command])
  if [nproc] >= [maxj] .or. ( [j1] = [id1] .and. [nproc] > 0 ) goto loop
  jfree = [maxj] - [nproc]
return [jfree]
*
macro waitpaw dir=directory 
  command = 'ls -1 '//[dir]//' | wc -l'
loop:
  wait ' ' 1; nproc = $shell([command])
  if [nproc] > 0 goto loop
return
*
* fnhead=richtree_CA7452. richtree_CA7480. richtree_ZA0003. richtree_ZA0014.
macro fit_i id0=1 id1=0 fitmod='VB' fpar='none' dir=data01 fnhead=richtree_ZA0014. _
            fntrail=.dat  ii0=1 ii1=3
  if [id1] = 0 then
    id1 = [id0]
  endif
  opt zfl; swi gz; ve/del *
  do i = [id0], [id1]
    mess ' ID = '[i]
    if [i] < 10 then
      filn = 0[i][fntrail]
    else
      filn = [i][fntrail]
    endif
    fil11 = [fnhead][filn]11.parerr
    filna = [filn]11.parerr
    fitA = 'no'
    if [fpar] = 'none' then
      filf = [fpar]
    elseif [fpar] = 'done' then
      filf =  [dir]/[fil11]
    else
      ve/cr parA(11) r;  ve/cr errA(11) r;  ve/cr parAi(11) r; ve/cr errAi(11) r
      ve/cr parAa(11) r; ve/cr errAa(11) r; ve/cr parAj(11) r; ve/cr errAj(11) r
      ve/read parAi,errAi [dir]/non-averaged/[filna]
      do j = [ii0], [ii1]
        fil11j = [dir]/nonavr[j]/[filna]
        ve/read parAj,errAj [fil11j]
        ve/copy $sigma(parAj+parA) parA
        ve/copy $sigma(errAj**2+errA) errA
      enddo
      nj = [ii1] - [ii0] + 1
      ve/copy $sigma(parA/[nj]) parA
      ve/copy $sigma(sqrt(errA)/[nj]) errA
      do j = 1, 12
        fil11j = [dir]/nat[j]/[filna]
        ve/read parAj,errAj [fil11j]
        ve/copy $sigma(parAj+parAa) parAa
        ve/copy $sigma(errAj**2+errAa) errAa
      enddo
      nj = 12
      ve/copy $sigma(parAa/[nj]) parAa
      ve/copy $sigma(sqrt(errAa)/[nj]) errAa
      if [fpar] = 'avrg' then
        ve/copy parAa(5:9) parAi(5:9); ve/copy errAa(5:9) errAi(5:9) | All-avrg SPE pars, no Nu1
      else
        ve/copy parA(4:9) parAi(4:9); ve/copy errA(4:9) errAi(4:9) | OD-avrg SPE pars
      endif
      filA = [fnhead][filn]A.parerr
      filf = [dir]/[filA]; fitA = 'yes'
      ve/write parAi,errAi [filf]
      ve/del parA,errA,parAi,errAi,parAa,errAa,parAj,errAj
    endif
    exec go [filn] [i] [dir] [filf] 5 15 [fitmod] [fnhead] [fntrail] [fitA]
  enddo
  shell rm fit_[dir]/[fnhead][id0]
return
*
macro vflush vx=xraw vy=n nnbin=250
* -- Remove from the fit all preceding zeros and non-contiguous(<3) non-zeros
* -- Remove from the fit all trailing zeros --
*
  nbins = $sigma(nco([vx]))
  i0 = 1; i1 = [nbins]; nbins2 = [nbins] - 2
  do i = 1 , [nbins2]
    ip1 = [i] + 1; ip2 = [i] + 2
    if [vy]([i]) > 0 .and. [vy]([ip1]) > 0 .and. [vy]([ip2]) > 0 then
      i0 = [i]
      goto cont
    endif
  enddo
cont:
  do i = [nbins] , 1 , -1
* -- Normal
    if [vy]([i]) > 0 then
* -- Kill all trailing "1"    if [vy]([i]) > 1 then
      i1 = [i]
      goto cont1
    endif
  enddo
cont1:
*  trace on
  nflush = [i1] - [i0] + 1; nrebin = $sigma(int([nflush]/[nnbin]))
  if [nnbin] = 0 .or. [nrebin] = 0 then
    ve/cr vflushx([nflush]) r; ve/cr vflushy([nflush]) r
    ve/copy [vx]([i0]:[i1]) vflushx
    ve/copy [vy]([i0]:[i1]) vflushy
    ve/del [vx],[vy]; ve/copy vflushx [vx]; ve/copy vflushy [vy]
  else
    nrbin  = $sigma(int([nflush]/[nrebin]))
    ve/cr rflushx([nrbin]); ve/copy rflushx rflushy
    ve/copy rflushx erfx;   ve/copy rflushx erfy
    nfbin = [nrbin]*[nrebin]; i01 = [i0] + 1; i11 = [i0] + [nfbin]
    x1 = [vx]([i0]); x2 = [vx]([i01]); xn = [vx]([i11]); dx = 0.5*([x2] - [x1])
    xl = [x1] - [dx]; xu = [xn] + [dx]
    1d 12345 'vflush' [nflush] [xl] [xu] 0.; put/cont 12345 [vy]([i0]:[i1])
    REBIN 12345 rflushx rflushy erfx erfy [nrbin] 1 [nfbin] N
    ve/del [vx],[vy]; ve/copy rflushx [vx]; ve/copy rflushy [vy]
    ve/del rflushx,rflushx,erfx,erfy; hi/del 12345
  endif
  ve/del vflushx,vflushy
*  trace off
return
*
macro gauss fped=dped78.dat jl=35 jr=45 idp=178 dir=akop ftot=dtot78.dat _
            idt=278 glen=6000 nnbin=270
  opt logy
  opt stat; set stat 1000100
  opt fit; set fit 111
  opt grid
  filecase keep
  clo 66
  if $vexist(xraw) then
    ve/del xraw,n,x,dxbn,parg,stpg,pmng,pmxg,errg
  endif
  if $hexist([idp]) then
    hi/del [idp]
    hi/del [idt]
  endif
*
  ve/read xraw,n [dir]/[fped] ! 'OC' -/h10/(*)
  if $vexist(xraw) = 0 then
    mess ' *** FATAL ERROR in reading the input file! Terminating...'
    goto ex
  endif
  nbins = $sigma(nco(xraw))
  if [nbins] < 10 then
    mess ' *** FATAL: Too few points in the input file! Terminating...'
    goto ex
  endif
*
  exec vflush vx=xraw vy=n nnbin=[nnbin]
  nbins = $sigma(nco(xraw)); nsum = $sigma(vsum(n))
  glenn = $sigma(min([nbins],[glen])); ve/copy n(1:[glenn]) gn
  ve/copy $sigma(diff(gn)) difgn | *** Use max and min of derivative
  idifmx = $sigma(lvmax(difgn)); idifmn = $sigma(lvmin(difgn))
  if [idifmn] > [idifmx] then
    ve/copy gn(1:[idifmn]) dgn
    ivmax = $sigma(lvmax(dgn)); ve/del gn,difgn,dgn
  else
    ivmax = $sigma(lvmax(gn));  ve/del gn,difgn
  endif
  xrmax = xraw([ivmax])
  ve/copy $sigma(xraw-([xrmax])) x;  ve/copy $sigma(diff(x)) dxbn
  dx = dxbn(1); xmin = x(1) - 0.5*[dx]; xmax = x([nbins]) + 0.5*[dx]
  1d [idp] [fped] [nbins] [xmin] [xmax] 0.
  put/cont [idp] n; call hbarx([idp])
  weight = 1./[nsum]
  add [idp] [idp] [idp] 0. [weight]
  ig1 = [ivmax]-[jl]; ig2 = [ivmax]+[jr]
  if [ig1] < 1 then
    ig1 = 1
  endif
  if [ig2] > [nbins] then
    ig2 = [nbins]
  endif
*
  ve/cr parg(3) r; ve/cr stpg(3) r; ve/cr errg(3) r; ve/cr pmng(3) r; ve/cr pmxg(3) r
  hi/fit [idp]([ig1]:[ig2]) g ! 0 parg stpg pmng pmxg errg
  call chiq
  ve/del xraw,n,x; ve/del dxbn
  goto ret
*
ex:
  xrmax = -1000000 | *** Error condition ***
ret:
return [xrmax]
*
macro allplot fnhead=richtree_ZA0014. dir=data01 npl=64
  exec plot nplots=[npl] ll=log tobin=2500 dir=[dir] fnhead=[fnhead] fit=11par xmin=-50 xmax=350
  exec plot nplots=[npl] ll=lin tobin=1100 dir=[dir] fnhead=[fnhead] fit=11par xmin=-50 xmax=250
return
*
macro allpl_b i0=1 i1=64 dir=data01 fnhead=richtree_ZA0014. fntrail=.txt xmin=-50 xmxln=250 xmxlg=350 _
              fname=test.dat
  shell rm -f   paw_[dir]
  shell rm -rf plot_[dir]
  shell mkdir  plot_[dir]
  shell ln -s $MCWORKS/paw/pawX11 paw_[dir]
  for/fil 72 plot_[dir]/plot_lin; clo 72
  exec plot_b [i0] [i1] lin 1100 [dir] [fnhead] [fntrail] 11par [xmin] [xmxln] [fname]
  for/fil 72 plot_[dir]/plot_log; clo 72
  exec plot_b [i0] [i1] log 2500 [dir] [fnhead] [fntrail] 11par [xmin] [xmxlg] [fname]
  exec waitpaw plot_[dir]
  shell rm ./paw_[dir]; shell rm -rf ./plot_[dir]; shell rm -rf /tmp/comis* >& /dev/null &
return
*
macro plot_b i0=1 i1=64 ll=log tobin=2500 dir=data01 fnhead=richtree_CA7452. fntrail=.txt _
             fit=11par xmin=-50 xmax=450 fname=test.dat
  exkumf = [dir]/p[ll].kumac; exlogf = [dir]/p[ll].log
  exline = 'exec ../../pmtfit/webfit11#plot '_
//[i0]//' '//[i1]//' '//[ll]//' '//[tobin]//' '_
//[dir]//' '//[fnhead]//' '//[fntrail]//' '//[fit]//' '_
//[xmin]//' '//[xmax]//' ps '//[fname]
  shell echo [exline]   > [exkumf]
  shell echo ' exit'   >> [exkumf]
  shell nice ./paw_[dir] -b [exkumf] >& [exlogf] &
return
*
macro plot i0=1 i1=64 ll=log tobin=2500 dir=data01 fnhead=richtree_CA7452. _
	  fntrail=.txt fit=11par xmin=-50 xmax=450 pstype=ps fname=test.dat
  opt zfl; swi gz; pi/del *; ve/del *
*
  nplots = [i1] - [i0] + 1
  do i = [i0] , [i1]
    if [i] < 10 then
      filn = 0[i][fntrail]
    else
      filn = [i][fntrail]
    endif
    fil11 = [dir]/[fnhead][filn]11.parerr
    fiv11 = [dir]/[fnhead][filn]11.idvec
    exec gopl [filn] [i] [dir] [fil11] 4 3 1 [tobin] [ll] [fiv11] [xmin] [xmax] [fnhead] [fname]
    if [@] = 0 then | *** It was Error in the gopl ***
      nplots = [nplots] - 1 
    endif
  enddo
  if [nplots] > 0 then
   if [pstype] = 'eps' then
     do i = [i0] , [i1] 
       exec pri eps [i] [i] [dir]/[fnhead]_[ll]_[fit]_[i] null 1 1
     enddo
   else
     exec pri land 1 [nplots] [dir]/[fnhead]_[ll]_[fit] null 1 1 | *** 1 plot/page
*     exec pri port 1 [nplots] [dir]/[fnhead]_[ll]_[fit] null 2 5 | *** 10 plots/page
     shell ps2pdf  [dir]/[fnhead]_[ll]_[fit].ps [dir]/[fnhead]_[ll]_[fit].pdf
     shell convert -density 250% -alpha deactivate [dir]/[fnhead]_[ll]_[fit].pdf ./[ll]fit.png
     wait ' ' 1; shell cp  ./[ll]fit.png  /scratch/pavel/rich/[ll]fit.png
     shell cp  ./[ll]fit.png  /scratch/pavel/rich/archive/[fnhead]_[ll]_[fit].png
     shell scp ./[ll]fit.png  jlabl1:/site/www/html/accel/RadCon/opsgraphs/rich/webfit/archive/[fnhead]_[ll]_[fit].png
     shell gzip -f [dir]/[fnhead]_[ll]_[fit].ps
   endif
  endif
  shell rm plot_[dir]/plot_[ll]
return
*
  macro rebinb x0=0. s=10. xmin=-1. dx=1. nbins=300 weight=1.e-6 Chi2=1.0 jl=7 jr=7
*
* -(1)- if Chi2 is not equal to 1.0 then errors around pedestal peak 
* -- will be increased such that the new Chi2 for the peak is equal to 1.0
* -- when Gaussian fitting function is used
* -- starting with x0+2*sigma find the point where the right value 
* -- becomes higher than <parameter>*<left value>, or goes over the local minimum
* --
* -(2)- Create the vector with statistically balanced points starting after max 
*
*  trace on
  if [jl] = 0 then
* -- Finding the right edge --
   ibp  = $sigma(int(([x0]+2.*[s]-([xmin]))/[dx])) | *** +2 sigma
   ibm  = $sigma(int(([x0]-2.*[s]-([xmin]))/[dx])) | *** -2 sigma
   ib = [ibp]; vpp = n([ib]);  if [ib] >= [nbins] goto foundib
   do i = [ibm] , 1, -1
     vp = n([ib]); vm = n([i]); vcmp = [vm]*100. | *** Parameter of asymmetry
     if [vp] > [vcmp] .or. [vp] > [vpp] .or. [ib] >= [nbins] goto foundib
     vpp = [vp]; ib = [ib] + 1
   enddo
   if [ibm] < 1 then 
     ibm = 1
   endif
foundib:
   ib = [ib] - 1
  elseif [jl] = -1 then
* -- Finding the right edge using x*n minimum --
   ibp  = $sigma(int(([x0]+20.*[s]-([xmin]))/[dx])) | *** +20 sigma
   ibm  = $sigma(int(([x0]-2.5*[s]-([xmin]))/[dx])) | *** -2.5 sigma
   ibs  = $sigma(int([nbins]/3.)) | *** Start hopefully to the left of the SPE peak
   ve/copy x([ibp]:[ibs]) xwork; ve/copy n([ibp]:[ibs]) nwork
   ve/copy $sigma(xwork*nwork*sqrt(sqrt(sqrt(abs(xwork))))) xnwork; ib = $sigma(lvmin(xnwork))
   ib = [ibp] + [ib] - 3
   if [ibm] < 1 then 
     ibm = 1
   endif
   ve/del xwork,nwork,xnwork
  else
* -- use jl and jl to set the gauss fit range --
   ibp  = $sigma(int(([x0]-([xmin]))/[dx])) | *** Position of the max
   ibm = [ibp] - [jl]; ib = [ibp] + [jr]
   if [ibm] < 1 then 
     ibm = 1
   endif
   if [ib]  >= [nbins] then 
     ib = [nbins] - 1
   endif

  endif
*
* -- Recalculate chi2 for the Gaussian fit of the peak below the asymmetry cut
*
  ve/copy $sigma(sqrt(n)) en
  ve/fit x([ibm]:[ib]) n([ibm]:[ib]) en([ibm]:[ib]) g ! 0 parg stpg pmng pmxg errg
  call chiq; Chi2g = chi2(1); mess 'New raw Chi2g = '[Chi2g]
*
* -- ib found:
**   ve/del nb
   ve/copy n([ib]:[nbins]) nb; ibmx = $sigma(lvmax(nb)); nbmax = nb([ibmx])
*
   nbmax = 9
   ibmx = [ibmx] + [ib] - 1
   ve/copy $sigma(x*n) xnb
   ve/cr xrbw([nbins]) r; ve/cr nrbw([nbins]) r; ve/cr enrbw([nbins]) r
   ve/copy x(1:[ibmx]) xrbw(1:[ibmx]); ve/copy n(1:[ibmx]) nrbw(1:[ibmx])
   ve/copy en(1:[ibmx]) enrbw(1:[ibmx]); ve/copy enrbw(1:[ib]) vppeak
   if [Chi2] <> 1.0 then | *** Condition to not increase Errors ***
     ve/copy $sigma(vppeak*sqrt([Chi2g])) enrbw(1:[ib]) | *** Error increase in the peak ***
   endif
   ve/cr peaklim(2) r 1 [ib]
   ve/del vppeak
   irl = [ibmx] + 1; iwl = [ibmx]
   if [irl] >= [nbins] goto eloops
loops:
     nrl = n([irl])
     if [nrl] > 0 then
       lirlnz = [irl]
     endif
     lzero = [irl] - [lirlnz]
     if [nrl] >= [nbmax] then
       iwl = [iwl] + 1
       ve/copy  x([irl]:[irl])  xrbw([iwl]:[iwl])
       ve/copy  n([irl]:[irl])  nrbw([iwl]:[iwl])
       ve/copy en([irl]:[irl]) enrbw([iwl]:[iwl])
     else
       nsum = [nrl]; ibb = [irl]; nbbl = 1
loopb:
       irl = [irl] + 1; nrl = n([irl])
       if [nrl] > 0 then
         lirlnz = [irl]
       endif
       lzero = [irl] - [lirlnz]
       nsum = [nsum] + [nrl]
       if [nsum] >= [nbmax] .or. [lzero] > 2 then
         if [nsum] > 0 then
           nbbl = [nbbl] + 1
           ve/copy xnb([ibb]:[irl]) xnbb
           navrg = [nsum]/[nbbl] 
           xavrg = $sigma(vsum(xnbb)); ve/del xnbb; xavrg = [xavrg]/[nsum]
           ve/cr work(2) r [nsum]; ve/copy $sigma([navrg]/sqrt(work)) work1
           enavrg = work1(1); ve/del work,work1
           ve/cr work(3) r [xavrg] [navrg] [enavrg]
           iwl = [iwl] + 1
           ve/copy  work(1)  xrbw([iwl]:[iwl])
           ve/copy  work(2)  nrbw([iwl]:[iwl])
           ve/copy  work(3) enrbw([iwl]:[iwl]); ve/del work
         endif
       elseif [irl]  >= [nbins] then
         goto eloops
       else
         nbbl = [nbbl] + 1
         goto loopb
       endif
     endif
     irl = [irl] + 1
     if [irl] < [nbins] .and. [lzero] < 3  goto loops
eloops:
   vscale nrbw [weight] nrbw; vscale enrbw [weight] enrbw
   ve/copy  xrbw(1:[iwl])  xrb; ve/copy nrbw(1:[iwl])    nrb
   ve/copy enrbw(1:[iwl]) enrb; ve/copy $sigma(xrb*0.0) exrb
   ve/del xrbw,nrbw,enrbw,nb,xnb,en
stop:
*trace off
return [iwl]
*
macro table dir=dir file=file PIX=1 ll=lin dy=0.06 Eff20=0 Eff25=0
*
  tsdatf = $shell('ls -1 *.tsdat'); ve/cr tsdat(6) r;  |***  ve/read tsdat [tsdatf]
  audatf = $shell('ls -1 *.audat'); ve/cr audat(64) r; |*** ve/read audat [audatf]
  CLS = tsdat(1); ALS = tsdat(2); CBSI = tsdat(5)
  augain = audat([PIX]); YIELD = 0                     |*** [augain]*[ALS]*[CBSI]/[CLS]
  dlfile = [dir]/[file].dl
  ndata = 45
* First number in ID_infoline: VER=3, then six numbers:
* VER PMT NTUBE RUNSET RPOS RUNT HV (1:7)
* CLS ALS ADC1000 ADC1100 CBSI GAIN (8:13) from tsdat
* PIX YIELD CHI2 NU2 NU3 A1 A3 NUAV (14:21) calculated values
* SC SSC  SIGMA SSIGMA  MU SMU  NU1 SNU1  A2 SA2  PNU2 SNU2 
*  PA3 SA3  PNU3 SNU3  XI SXI  BETA SBETA  TAU STAU (22:43) - parameters+errors
* EFF20 EFF25 (44:45) - efficiencies at the thresholds of 20 and 25 ADC channels 
*
  ve/cr idver(1) r; ve/read idver [dir]/ID_infoline; ver=idver(1); ve/del idver
  if [ver] = 3 then
    ve/cr info(7) r; ve/read info(1:7) [dir]/ID_infoline
  else
    mess ' %%% webfit11#table: Error in the ID_infoline version! %%%'
  endif
  formtx = [ndata]//'E14.6'; ve/cr datline([ndata]) r
  ytx = 0.91; xeq = 0.81; xpm = 0.89; xmm = 0.915; xre = 0.975; fsiz=0.32
  txt0 = '[v]^2!/NDF   = '; txt1 = 'Scale (channels per 1 ph.e.) ='
  txt2 = '[s] (channels) ='; txt3 = '[m]  ='
  txt4 =  '[n]?1! ='; txt5 = '[a]?2! ='; txt6 = '[n]?2!/[n]?1! ='
  txt7 = '[a]?3!/(1-[a]?2!) ='; txt8 = '[n]?3!/[n]?1! ='; txt9 = '[x]  ='
  txt10 = '[b]  ='; txt11 = '[t]/[s] ='
*
  sigma = part(2); mu   = part(3); nu1 = part(4); a2 = part(5); pnu2 = part(6)
  pa3 = part(7); pnu3 = part(8); xi   = part(9); beta = part(10); tau = part(11)
  nu2 = [pnu2]*[nu1]; a3 = [pa3]*(1.-[a2]); nu3 = [pnu3]*[nu1]; a1 = 1.-[a2]-[a3] 
  nuav = [nu1]*[a1]+[nu2]*[a2]+[nu3]*[a3]
  ftnuav = $format([nuav],'F7.2'); txnuav = '[n]?average!  = '//[ftnuav]
  CHI2 = chiq(1); tchi2 = $format([CHI2],'F7.2'); ich1=[nhead]+1; ich2=[ich1]+1
  exec  notes [xpm] [ytx] [tchi2] 0. 0.4 defont
  exec rnotes [xpm] [ytx] [txt0]  0. 0.4 defont; ytx = [ytx] - 0.015
  do i = 1 , 11
    ytx[i] = [ytx] - [dy]; ytx = [ytx[i]]
  enddo
*
  ve/copy info datline(1:7); ve/copy tsdat datline(8:13)
  ve/cr work(8) r [PIX] [YIELD] [CHI2] [nu2] [nu3] [a1] [a3] [nuav]
  ve/copy work datline(14:21); ve/del work
  ntablin = 11
  if [beta] = 0.0 then
    ntablin = 9
  endif
  do i = 1 , [ntablin]
    i0 = 20 + 2*[i]; i1 = [i0] + 1
    par = part([i]); err = errt([i]); ytx = [ytx[i]]
    ve/cr work(2) r [par] [err]; ve/copy work datline([i0]:[i1]); ve/del work
    txt = [txt[i]]
    if [i] = 1 .or. [i] = 4 .or. [i] = 9 then
      txpar = $format([par],'F7.2'); txerr = $format([err],'F9.2')
    elseif [i] = 3 then
      txpar = $format([par],'F7.4'); txerr = $format([err],'F9.4')
    else
      txpar = $format([par],'F7.3'); txerr = $format([err],'F9.3')
    endif
    exec rnotes [xeq] [ytx] [txt]    0. [fsiz] defont
    exec snotes [xeq] [ytx] [txpar]  0. [fsiz] defont
    exec snotes [xpm] [ytx] '[\261]' 0. [fsiz] defont
    exec snotes [xpm] [ytx] [txerr]  0. [fsiz] defont
  enddo
  ytx = [ytx] - [dy]; exec snotes [xeq] [ytx] [txnuav] 0. [fsiz] defont
*
  if [ll] = 'lin' then | *** avoid writing the file in parallel by the 'lin' and 'log' processes
    ve/cr work(2) r [Eff20] [Eff25]; ve/copy work datline(44:45); ve/del work
    ve/write datline [dlfile] [formtx]
  endif
  ve/del info,tsdat,audat,datline
return [ytx]
*
macro rplot_par dir=CA7610.v3.1000
*
  exec pl; filecase keep; Graphics/Vie/Size 24 15.5
  filecase keep; ve/del *; opt zfl; swi gz; pi/del *
  ve/cr idver(1) r; ve/read idver ID_infoline; ver=idver(1); ve/del idver
  if [ver] <> 3 goto stop
*
  exec setpq; opt tic
  dlfile = [dir].table; nd = 45; formtx = [nd]//'E14.6'
  psfile = pl_par11_[dir]
*
* VER PMT NTUBE RUNSET RPOS RUNT HV (1:7)
* CLS ALS ADC1000 ADC1100 CBSI GAIN (8:13) from tsdat
* PIX YIELD CHI2 NU2 NU3 A1 A3 NUAV (14:21) calculated values
* SC SSC  SIGMA SSIGMA  MU SMU  NU1 SNU1  A2 SA2  PNU2 SNU2 
*  PA3 SA3  PNU3 SNU3  XI SXI  BETA SBETA  TAU STAU (22:43) - parameters+errors
* EFF20 EFF25 (44:45) - efficiencies at the thresholds of 20 and 25 ADC channels 
*
  ve/cr tab(45,64) r; ve/read tab  [dlfile] [formtx]
*
  exec fltb ver 1;    exec fltb pmt 2;     exec fltb ntube 3;    exec fltb runset 4
  exec fltb rpos 5;   exec fltb runt 6;    exec fltb hv 7
  exec fltb cls 8;    exec fltb als 9;     exec fltb adc1000 10; exec fltb adc1100 11
  exec fltb cbsi 12;  exec fltb gain 13
  exec fltb pix 14;   exec fltb yield 15;  exec fltb chi2 16;    exec fltb nu2 17
  exec fltb nu3 18;   exec fltb a1 19;     exec fltb a3 20;      exec fltb nuav 21
  exec fltb scale 22; exec fltb sscale 23; exec fltb s 24;       exec fltb ss 25
  exec fltb mu 26;    exec fltb smu 27;    exec fltb nu1 28;     exec fltb snu1 29
  exec fltb a2 30;    exec fltb sa2 31;    exec fltb pnu2 32;    exec fltb snu2 33
  exec fltb pa3 34;   exec fltb sa3 35;    exec fltb pnu3 36;    exec fltb snu3 37
  exec fltb xi 38;    exec fltb sxi 39;    exec fltb b 40;       exec fltb sb 41
  exec fltb t 42;     exec fltb st 43;     exec fltb eff20 44;   exec fltb eff25 45
*
*  ve/read ver,pmt,ntube,runset,rpos,runt,hv,cls,als,adc1000,adc1100,cbsi,gain,_
*pix,yield,chi2,nu2,nu3,a1,a3,nuav,scale,sscale,s,ss,mu,smu,_
*nu1,snu1,a2,sa2,pnu2,snu2,pa3,sa3,pnu3,snu3,xi,sxi,b,sb,t,st [dlfile] [formtx]
*
  opt hori; set ywin 0.25; zone 1 1; title ' '
*
  mnscale = $sigma(vmin(scale)); mxscale = $sigma(vmax(scale))
  ymin = [mnscale] - ([mxscale]-[mnscale])/15 - 0.5
  ymax = [mxscale] + ([mxscale]-[mnscale])/10 + 0.5
  set xlab 1.45; null 0. 65. [ymin] [ymax]; title ' '
  exec red;  graph 64 pix scale l; exec black; h/err pix scale ? sscale 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 'scale (channels per 1 p.e.)' 0. 0.5 defont
*
  mnmu = $sigma(vmin(mu)); mxmu = $sigma(vmax(mu))
  ymin = [mnmu] - ([mxmu]-[mnmu])/15
  ymax = [mxmu] + ([mxmu]-[mnmu])/10
  set xlab 1.45; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix mu l; exec black; h/err pix mu ? smu 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[m]' 0. 0.5 defont
  exec snotes 0.30 1.10 [dir] 0. 0.7 defont
*
  mxchi2 = $sigma(vmax(chi2))
  ymin = 0.
  ymax = [mxchi2] + [mxchi2]/10; opt date
  set xlab 1.15; null 0. 65. [ymin] [ymax]; opt ndat
  exec red; graph 64 pix chi2 l; exec black; h/err pix chi2 ? ? 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[v]^2!/NDF' 0. 0.5 defont
*
  mnnu1 = 0; mxnu1 = $sigma(vmax(nu1))
  ymin = [mnnu1] - ([mxnu1]-[mnnu1])/15
  ymax = [mxnu1] + ([mxnu1]-[mnnu1])/10
  set xlab 1.45; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix nu1 l; exec black; h/err pix nu1 ? snu1 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[n]?1!' 0. 0.5 defont
*
  mna2 = 0; mxa2 = $sigma(vmax(a2))
  ymin = [mna2] - ([mxa2]-[mna2])/15
  ymax = [mxa2] + ([mxa2]-[mna2])/10
  set xlab 1.15; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix a2 l; exec black; h/err pix a2 ? sa2 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[a]?2!' 0. 0.5 defont
*
  mnnu2 = 0; mxnu2 = $sigma(vmax(pnu2))
  ymin = [mnnu2] - ([mxnu2]-[mnnu2])/15
  ymax = [mxnu2] + ([mxnu2]-[mnnu2])/10
  set xlab 1.15; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix pnu2 l; exec black; h/err pix pnu2 ? snu2 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[n]?2!/[n]?1!' 0. 0.5 defont
*
  mna3 = 0; mxa3 = $sigma(vmax(pa3))
  ymin = [mna3] - ([mxa3]-[mna3])/15
  ymax = [mxa3] + ([mxa3]-[mna3])/10
  set xlab 1.15; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix pa3 l; exec black; h/err pix pa3 ? sa3 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[a]?3!/(1-[a]?2!)' 0. 0.5 defont
*
  mnnu3 = 0; mxnu3 = $sigma(vmax(pnu3))
  ymin = [mnnu3] - ([mxnu3]-[mnnu3])/15
  ymax = [mxnu3] + ([mxnu3]-[mnnu3])/10
  set xlab 1.15; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix pnu3 l; exec black; h/err pix pnu3 ? snu3 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[n]?3!/[n]?1!' 0. 0.5 defont
*
  set yval; set ylab
*
  mns = $sigma(vmin(s)); mxs = $sigma(vmax(s))
  ymin = [mns] - ([mxs]-[mns])/15
  ymax = [mxs] + ([mxs]-[mns])/10
  set xlab 1.45; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix s l; exec black; h/err pix s ? ss 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[s]?meas! (channels)' 0. 0.5 defont
*
  mnxi = $sigma(vmin(xi)); mxxi = $sigma(vmax(xi))
  ymin = [mnxi] - ([mxxi]-[mnxi])/15
  ymax = [mxxi] + ([mxxi]-[mnxi])/10
  set xlab 1.15; null 0. 65. [ymin] [ymax]
  exec red;  graph 64 pix xi l; exec black; h/err pix xi ? sxi 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[x]' 0. 0.5 defont
*
  mxb = $sigma(vmax(b))
  ymin = 0.
  ymax = [mxb] + [mxb]/10
  set xlab 1.15; null 0. 65. [ymin] [ymax]
  exec red; graph 64 pix b l; exec black; h/err pix b ? sb 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[b]' 0. 0.5 defont
*
  mxt = $sigma(vmax(t))
  ymin = 0.
  ymax = [mxt] + [mxt]/10
  set xlab 1.15; null 0. 65. [ymin] [ymax]
  exec red; graph 64 pix t l; exec black; h/err pix t ? st 64 25 .1 0
  exec black; atitle 'pixel number' ' ' ' ' 222
  exec  notes 0.02 1.077 '[t]' 0. 0.5 defont
*
  exec pri land 1 12 [psfile] null 3 4
  shell ps2pdf [psfile].ps; shell gzip -f [psfile].ps
stop:
return
*
macro fltb vect=ver vid=1 vtab=tab nvec=45 npix=64
  ve/cr [vect]([npix]) r
  do i = 1 , [npix]
    ve/copy [vtab]([vid],[i]:[i]) [vect]([i]:[i])
  enddo
return
*
macro pres ymin=0.1e-8 ymax=0.001 ll=log xmin=-0.5 xmax=5.5 nbins=1000 _
           scale=1. s=0.012 mu=0.1 nu1=18.6 a2=0.19 nu2=0.19 _
           a3=0.07 nu3=0.54 xi=16.0 beta=0.0 tau=2.0
*
  filecase keep
  mmax=20
  if $vexist(compile) = 0 then
    ve/cr par(11) r; ve/cr err(11) r; ve/cr parg(3) r; ve/cr errg(3) r; ve/cr idvec(5) r 
    ve/cr compile(1) r
    exec ../../pmtfit/comisSetPath.kumac
    call ../../pmtfit/ppmt11.f77(0.0)
  endif
*
  ve/cr vidvi(5) r [nbins] [xmin] [xmax] 0. 0.
  ve/copy vidvi idvec; ve/del vidvi
  ve/cr vpar(11)  r [scale] [s] [mu] [nu1] [a2] [nu2] [a3] [nu3] [xi] [beta] [tau]
  ve/copy vpar par; ve/del vpar
*
  exec black; opt [ll]y
  opt stat; set stat 1111111; opt fit; set fit 111; opt ngri
  points [nbins]
*
  opt fit; set fit 111; opt tic
  opt ngri
  exec black; opt utit
  mutxt = 'PMT Signal Amplitude Distributions for [m] = '//[mu]
  title [mutxt]
  title 'Number of Photoelectrons' u
  ymx = [ymax] / [s]
  null [xmin] [xmax] [ymin] [ymx]
  title ' ' u; title ' '
  set hwid 5; set fwid 5
  set hcol 2; fu/pl fpres(x,0,[mmax]) [xmin] [xmax] s
  hi/copy 12345 100
  set hwid 1; set fwid 1; set hcol 3; fu/pl fpres(x,0,0) [xmin] [xmax] s
  idi = 1000; hi/copy 12345 [idi]
  set hcol 4; mpmax = [mmax] - 2
  do i = 1, [mpmax]
    fu/pl fpres(x,[i],[i]) [xmin] [xmax] s
    idi = 1000 + [i]; hi/copy 12345 [idi]
  enddo
  exec red;    exec  notes 0.03 0.96 'Red: JLab Model' 0. .32 defont 
*  exec violet; exec snotes 0.43 0.96 'Violet: JLab Model Components' 0. .32 defont 
*
  exec black; opt [ll]y
***  opt stat; set stat 11111111; hi/pl 100
stop:
return
*
macro pleps filn=639.dat id=639 dir=k1 fpar=k1/hist4639.dat11.parerr _
 jl=4 jr=3 frbin=1 tobin=520 ll=log fidv=k1/hist4639.dat11.idvec _
 xsmin=-50 xsmax=450 fnhead=hist4
*
  filecase keep; exec pl
  if $vexist(compile) = 0 then
    ve/cr par(11) r; ve/cr err(11) r; ve/cr parg(3) r; ve/cr errg(3) r; ve/cr idvec(5) r 
    ve/cr compile(1) r
    exec ../../pmtfit/comisSetPath.kumac
    call ../../pmtfit/ppmt11.f77(0.0)
  endif
*
  file = [fnhead][filn]; filg = [fnhead][filn]
  ve/cr vidvi(5) r; ve/read vidvi [fidv]
  nbins = vidvi(1); xmin = vidvi(2); xmax = vidvi(3)
  mean  = vidvi(4); x0   = vidvi(5)
  ve/copy vidvi idvec; ve/del vidvi
*
  exec black; opt [ll]y
  Graphics/Vie/Size 24 12
  opt nsta; opt fit; set fit 111; opt ngri; exec setpq; opt tic
  points 1000; title ' ' u
  ttx = [dir]/[file]
  if     [dir] = 'data' then
    ttx = 'ET Enterprises 9823B PMT, Light Test Setup"F# '//[id]
  elseif [dir] = 'ZA0175.l3.1100' then
    ttx = 'H12700 PSPMT"F# ZA0175, HV = 1100 V. Anode"F# '//[id]
  endif
  plid = ' '
  if [id] = 1 then
    plid = '(a)'
  elseif [id] = 2 then
    plid = '(b)'
  elseif [id] = 3 then
    plid = '(c)'
  elseif [id] = 4 then
    plid = '(d)'
  elseif [id] = 5 then
    plid = '(e)'
  elseif [id] = 6 then
    plid = '(f)'
  endif
  plid = ' '
  ttx  = ' '
  title [ttx]
  ve/read par,err [fpar]
  fxnerb = [dir]/[file]11.xnerb; fchiq = [dir]/[file]11.chiq
  if $vexist(xrb) = 1 then
    ve/del xrb,nrb,exrb,enrb,chiq
  endif
  ve/read xrb,nrb,enrb [fxnerb]; ve/cr chiq(4) r; ve/read chiq [fchiq]
  iwl = $sigma(nco(xrb)); iwl = [iwl] - 1 
*
  Scale = par(1); Sigma = par(2); mu = par(3); Beta = par(10); Tau = par(11)
  x0corr = [mean] - ([Beta]*([Tau])*[Sigma]) - ([Scale]*[mu])
  wpoiss = $sigma(1.5/[scale]*exp(-[mu])*[mu])
  if $hexist([id]) then
    hi/del [id]
  endif
  hi/fil 66 [dir]/[file]11.hbook
  hrin [id]
  clo 66
  wpoiss = [wpoiss]*[dx]; mxscale = [wpoiss]*1.75
  if [ll] = 'lin' then
    mnscale = 0.; mnvis = 0.; mxvis = 1.99
  else
    mnscale = [mxscale] * 0.1e-3; mnvis = 0.002
    mxscale = [mxscale] * 700.;   mxvis = 50.0
  endif
  min [id] [mnscale]; max [id] [mxscale]
  set dmod 1; set hwid 3; set fwid 3
  mns1000 = [mnscale]*1000; mxs1000 = [mxscale]*1000
  xsmin0 = [xsmin]+([x0corr]); xsmax0 = [xsmax]+([x0corr])
  exec black;  null [xsmin] [xsmax] [mnvis] [mxvis]; pi/rena ' ' axis
  set xval 70.; set yval 70; null [xsmin] [xsmax] [mns1000] [mxs1000]
  set xval; set yval; null [xsmin0] [xsmax0] [mnscale] [mxscale] abs; exec setsq
  mxsc = [mxscale]*0.997; mxfl = $format([mxsc],'E10.2')
  atitle 's = s?meas! - s?ped! (channels ADC)' 'dN/ds p.d.f. (arb. units)' ' ' 222
*
  ve/cr xw([nbins]) r; ve/cr yw([nbins]) r; ve/cr exw([nbins]) r; ve/cr eyw([nbins]) r
  REBIN [id] xw yw exw eyw [nbins] 1 [nbins]
  set bwid 1; h/err xw yw exw eyw [nbins] 1 .001; ve/del xw,yw,exw,eyw
  ve/copy $sigma(xrb*0.0) exrb
*
  exec blue;  set dmod 1; set hwid 1; set htyp 144; fu/pl fplot(x,1,1) [xsmin] [xsmax] s
  exec blue;  set dmod 1; set hwid 1; set htyp 109; fu/pl fplot(x,1,1) [xsmin] [xsmax] s
  exec black; set dmod 2; set hwid 5; exec black
  ve/cr ihtyp(10) r 56 75 57 65 58 59 45 85 35 15
  do i = 2, 11
    j = [i] - 1; jht = ihtyp([j])
    set htyp 2[jht]; fu/pl fplot(x,[i],[i]) [xsmin] [xsmax] s
  enddo
  ve/del ihtyp
*
*  set dmod 1; set hwid 9; exec white 8
*  fu/pl pfplot(x,1,1,0) [xsmin] [xsmax] s
*  fu/pl pfplot(x,1,1,1) [xsmin] [xsmax] s
*  fu/pl pfplot(x,1,1,2) [xsmin] [xsmax] s
**
*  set dmod 3; set hwid 5; exec black
*  fu/pl pfplot(x,1,1,0) [xsmin] [xsmax] s
*  fu/pl pfplot(x,1,1,1) [xsmin] [xsmax] s
*  fu/pl pfplot(x,1,1,2) [xsmin] [xsmax] s
**
*  set dmod 1; set hwid 9; exec white 8; fu/pl fplot(x,0,0) [xsmin] [xsmax] s
*  set dmod 1; set hwid 9; exec white 8; fu/pl fplot(x,1,1) [xsmin] [xsmax] s
  do i = 2, 11
    set dmod 1; set hwid 5; exec white 8; fu/pl fplot(x,[i],[i]) [xsmin] [xsmax] s
  enddo
*
  set dmod 2; set hwid 5; exec black;   fu/pl fplot(x,0,0) [xsmin] [xsmax] s
*  set dmod 2; set hwid 5; exec black;   fu/pl fplot(x,1,1) [xsmin] [xsmax] s
  do i = 2, 11
    set dmod 2; set hwid 5; exec black;   fu/pl fplot(x,[i],[i]) [xsmin] [xsmax] s
    mean[i] = $hinfo(12345,'mean'); rmean[i] = ([mean[i]]-([x0]+[x0corr])) / [scale]
    mess [rmean[i]]
  enddo
*
  set dmod 2; set hwid 5; exec black; set htyp 350; fu/pl fplot(x,1,1) [xsmin] [xsmax] s
*  set dmod 1; set hwid 9; exec white 8; fu/pl fplot(x,1,1) [xsmin] [xsmax] s
  set dmod 2; set hwid 5; exec black;   fu/pl fplot(x,1,1) [xsmin] [xsmax] s
  set dmod 1; set hwid 9; exec white 8; fu/pl fplot(x,0,16) [xsmin] [xsmax] s
  set dmod 1; set hwid 5; exec white 8; fu/pl fplot(x,0,0) [xsmin] [xsmax] s
  set hwid 5;             exec black;   fu/pl fplot(x,0,16) [xsmin] [xsmax] s
  set dmod 2; set hwid 5; set htyp 345
  fu/pl min($unquote([mxfl]),fplot(x,0,0)) [xsmin] [xsmax] s
  set bwid 3; set hwid 3; exec black;   h/err xrb nrb exrb enrb [iwl] 25 .07 0
  set bwid 1; set hwid 1; exec white 8; h/err xrb nrb exrb exrb [iwl] 25 .04 0
  set dmod 1; set hwid 2; exec black;   fu/pl fplot(x,0,16) [xsmin] [xsmax] s
  ve/del xrb,exrb,nrb,enrb; exec black
*
  exec table [scale] [dir] [file] [id]
  exec snotes 0.0 1.05 [plid] 0 .7 defont
  exec snotes 0.12 0.92 'Solid line: ' 0. 0.42 defont
  exec snotes 0.27 0.92 'dN/ds = f?PMT!(s;? !parameters)' 0. 0.42 -50
  pi/me axis
  pi/del axis
  exec black
**
** -- Create 1-ph.e. distributions function of A (A=1 corresponds to 1 ph.e)
*  ncfx=1000; fxmn=-0.5; fxmx=4.5; ss=[s]/[scale]
*  ve/cr work(6) r [ncfx] [fxmn] [fxmx] 0. 0.; ve/copy work idvec(1:5); ve/del work
*  fun1 257257 fpres(x,1,1) [ncfx] [fxmn] [fxmx] ' '
*  ve/cr xfun([ncfx]) r; ve/cr exfun([ncfx]) r; ve/cr ffun([ncfx]) r; ve/cr effun([ncfx]) r
*  rebin 257257 xfun ffun exfun effun [ncfx] 1 [ncfx]
*  ve/write xfun,ffun [dir]/[file]11.spes '2E14.6'
*  ve/del xfun,ffun,exfun,effun; hi/del 257257
*
stop:
return
